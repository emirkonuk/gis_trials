<!doctype html><html><head>
<meta charset="utf-8"/><title>Raster + Vectors (named)</title>
<script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
<link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet"/>
<style>
  html,body,#map{height:100%;margin:0}
  #ui{position:absolute;top:10px;left:10px;background:#fff;border:1px solid #ccc;padding:8px 10px;max-height:70%;overflow:auto;font:14px system-ui}
  #group{margin-top:6px;padding-left:6px;border-left:3px solid #eee}
  .layer-row{display:flex;align-items:center;gap:6px;margin:3px 0}
  .swatch{width:12px;height:12px;border:1px solid #999;display:inline-block}
  .muted{opacity:.6}
</style>
</head><body>
<div id="map"></div>
<div id="ui">
  <div class="layer-row"><label><input id="chk-raster" type="checkbox" checked> raster</label></div>
  <div class="layer-row"><label for="rasterSource">year</label>
    <select id="rasterSource">
      <option value="2017" selected>2017 RGB</option>
      <option value="2011">2011 archive</option>
    </select>
  </div>
  <div class="layer-row"><label><input id="chk-vectors" type="checkbox"> vectors</label></div>
  <div id="group" class="muted"></div>
</div>
<script>
const ORIGIN='http://127.0.0.1:8080';
let NAME_MAP={};
const rasterCheckbox=document.getElementById('chk-raster');
const rasterSelect=document.getElementById('rasterSource');
let currentRasterLayer=null;
const rasterLayerIds={};

function labelFor(id, fallback){ return NAME_MAP[id] || fallback || id; }
function colorFor(id){ let h=0; for(let i=0;i<id.length;i++) h=(h*31+id.charCodeAt(i))>>>0; return `hsl(${h%360} 90% 45%)`; }

const map=new maplibregl.Map({container:'map',style:{version:8,sources:{},layers:[]},center:[18.10,59.35],zoom:14,minZoom:2,maxZoom:24});
const added=new Set();

map.on('load', async ()=>{
  const rasterSources={
    '2017': `${ORIGIN}/raster/ortho_2017/tiles/{z}/{x}/{y}.jpg`,
    '2011': `${ORIGIN}/raster/ortho_2011/tiles/{z}/{x}/{y}.jpg`
  };
  Object.entries(rasterSources).forEach(([year,url])=>{
    const sourceId=`ortho-${year}`;
    const layerId=`${sourceId}-layer`;
    map.addSource(sourceId,{type:'raster',tiles:[url],tileSize:256,minzoom:0,maxzoom:24});
    map.addLayer({id:layerId,type:'raster',source:sourceId,layout:{visibility: year===rasterSelect.value?'visible':'none'}});
    rasterLayerIds[year]=layerId;
  });

  const syncRasterVisibility=()=>{
    Object.values(rasterLayerIds).forEach(layer=>{
      if(map.getLayer(layer)) map.setLayoutProperty(layer,'visibility','none');
    });
    currentRasterLayer=rasterLayerIds[rasterSelect.value];
    if(currentRasterLayer){
      map.setLayoutProperty(currentRasterLayer,'visibility', rasterCheckbox.checked?'visible':'none');
    }
  };
  rasterCheckbox.addEventListener('change',syncRasterVisibility);
  rasterSelect.addEventListener('change',syncRasterVisibility);
  syncRasterVisibility();

  // 2) Load names BEFORE building vector UI
  try {
    const r=await fetch(`${ORIGIN}/layer_names.json`,{headers:{'Accept':'application/json'}});
    if(r.ok) NAME_MAP=await r.json();
  } catch {}

  // 3) Fetch vector index and build UI
  const group=document.getElementById('group');
  let idx={}; try{
    const r=await fetch(`${ORIGIN}/vector/index.json`,{headers:{'Accept':'application/json'}});
    idx=await r.json();
  } catch { group.innerHTML='<div style="color:#b00">failed to load /vector/index.json</div>'; return; }

  const entries=Object.values(idx);
  group.innerHTML='';
  for(const ent of entries){
    const id=ent.id, label=labelFor(id, ent.name), color=colorFor(id);
    const row=document.createElement('div');
    row.className='layer-row';
    row.innerHTML=`<span class="swatch" style="background:${color}"></span>
                   <label><input type="checkbox" data-id="${id}"> ${label}</label>`;
    group.appendChild(row);
  }

  // Master toggle
  const master=document.getElementById('chk-vectors');
  const setGroupEnabled=on=>{
    group.classList.toggle('muted',!on);
    group.querySelectorAll('input[type=checkbox]').forEach(cb=>{
      cb.disabled=!on;
      if(!on && cb.checked){ cb.checked=false; toggleOne(cb.dataset.id,false); }
    });
  };
  setGroupEnabled(false);
  master.addEventListener('change',e=>setGroupEnabled(e.target.checked));

  // Per-layer toggle
  group.addEventListener('change', async ev=>{
    const cb=ev.target; if(!cb?.dataset?.id) return;
    const id=cb.dataset.id;
    if(cb.checked && !added.has(id)){
      let geom=''; try{
        const d=await (await fetch(`${ORIGIN}/vector/${id}.json`,{headers:{'Accept':'application/json'}})).json();
        geom=(d.geometrytype||'').toLowerCase();
      }catch{}
      const color=colorFor(id);
      map.addSource(id,{type:'vector',tiles:[`${ORIGIN}/vector/${id}/{z}/{x}/{y}.pbf`],minzoom:0,maxzoom:22});
      if(geom.includes('polygon')){
        map.addLayer({id:`${id}-fill`,type:'fill',source:id,'source-layer':id,paint:{'fill-color':color,'fill-opacity':0.20}});
        map.addLayer({id:`${id}-outline`,type:'line',source:id,'source-layer':id,paint:{'line-color':color,'line-width':2}});
      }else if(geom.includes('line')){
        map.addLayer({id:`${id}-line`,type:'line',source:id,'source-layer':id,paint:{'line-color':color,'line-width':2}});
      }else{
        map.addLayer({id:`${id}-point`,type:'circle',source:id,'source-layer':id,paint:{'circle-radius':3,'circle-color':color}});
      }
      added.add(id);
    }
    toggleOne(id, cb.checked);
  });

  function toggleOne(id, show){
    (map.getStyle().layers||[]).filter(l=>l.id.startsWith(id+'-'))
      .forEach(l=>map.setLayoutProperty(l.id,'visibility', show?'visible':'none'));
  }
});
</script>
</body></html>
